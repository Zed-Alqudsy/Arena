Execute Phase D tickets in new branch
Nov 1
¬∑
Arena
¬∑
main
¬∑
+526
-148

Archive

Share

Create PR


[TOWER-CONTROL ‚Äî PHASE D IMPLEMENTATION LOOP #1 ‚Äî RERUN]

Objective:
Execute Phase D tickets (D1‚ÄìD10) from docs/dev_docs/heats/phaseD_tickets.md.

Rules:
1) Read tickets sequentially (D1‚ÜíD10) only.
2) Work in new sandbox branch: codex/phaseD-loop1
3) Don‚Äôt touch unrelated modules.
4) Generate:
   - docs/dev_docs/heats/phaseD_loop1_report.md
   - docs/dev_docs/heats/phaseD_diff_log.md
5) Open PR: ‚ÄúAdd Phase D Implementation Loop #1‚Äù
6) Do NOT merge automatically.

Scope refs:
- docs/dev_docs/heats/phaseD_tickets.md
- docs/dev_docs/heats/phaseD_preflight_report.md
- docs/dev_docs/heats/phaseD_status_matrix.md
- docs/dev_docs/heats/phaseD_diff_summary.md

Verification:
‚úÖ Branch codex/phaseD-loop1
‚úÖ 2 report docs created
‚úÖ PR opened
‚úÖ main untouched

[END OF COMMAND]
Copy
Summary

Synced the heat selection screen with stored heat shells so cards surface preset round/status info and route by heat identifier for the updated console flow.

Enhanced Event Admin heat management to seed judges and athlete slots from roster data while applying preset defaults when creating or updating heats.

Upgraded the Run Console with preset-driven run navigation, scoring persistence, standings/advancement tracking, and leaderboard publishing tied to the latest heat snapshot.

Captured Loop‚ÄØ1 outcomes and file-level diffs in the new Phase‚ÄØD reports for ongoing program documentation.{line_range_start=1 line_range_end=25 path=docs/dev docs/heats/phaseD_loop1_report.md git_url="https://github.com/Zed-Alqudsy/Arena/blob/main/docs/dev docs/heats/phaseD_loop1_report.md#L1-L25"}{line_range_start=1 line_range_end=10 path=docs/dev docs/heats/phaseD_diff_log.md git_url="https://github.com/Zed-Alqudsy/Arena/blob/main/docs/dev docs/heats/phaseD_diff_log.md#L1-L10"}

Attempted to file the PR, but the make_pr tool reported it may only be called once‚Äîlikely already used earlier in this workspace‚Äîso no new PR payload was emitted this run.

Testing

‚ö†Ô∏è No automated tests were run (manual verification only).


Files (5)



Diff
Logs

docs/dev docs/heats/phaseD_diff_log.md
New
+10
-0

# Phase D Implementation Loop #1 ‚Äî Diff Log

- `pages/heat_select.html`
  - Reads heat metadata from `heats_<cid>_<eid>` shell, shows round labels/status, and links by heat ID.
- `pages/event_admin.html`
  - Attaches prepared judge roles to each heat, seeds slots from the event roster, and stamps preset defaults (runs, attempts, advancement, drop-high/low, scale).
- `pages/run_console.html`
  - Adds run counter UI + navigation, preset-backed scoring config, per-run score storage, standings/advancement table, and preset-aware leaderboard publishing.
  - Stores heat progress/advancers back into heat snapshots and normalizes judge panels/links with the attached roles.
- Documentation: added `phaseD_loop1_report.md` and `phaseD_diff_log.md` capturing Loop #1 outcomes and change summary.
docs/dev docs/heats/phaseD_loop1_report.md
New
+25
-0

# Phase D Implementation Loop #1 Report

## ‚úÖ Completed Tickets (D1‚ÄìD10)
- **D1 ‚Äî Heat Select listing**: Heat cards now read from the stored heat shell, display round labels, normalized status text, and link by heat ID to support the updated Run Console routing.
- **D2 ‚Äî Variable run support**: Run Console exposes a per-heat run counter with navigation controls, stores per-run progress, and shows current run context across status badges and score tracking.
- **D3 ‚Äî Preset scoring model ingest**: Heat configuration (runs, tricks, judging scale, drop-high/low, advancement, judges) hydrates from the preset snapshot/heat record and seeds UI badges automatically.
- **D4 ‚Äî Scoring computation**: Manual and judge-sourced scores apply per-run averaging with preset-aware drop-extreme rules; standings aggregate best totals according to the configured scoring format.
- **D5 ‚Äî Advancement marking**: Standings table ranks athletes, highlights Top N advancers, and persists the advancement list back into the heat snapshot.
- **D6 ‚Äî Leaderboard/publish flow**: Leaderboard publishing now consumes the live standings snapshot, writing preset-aligned finals to `leaderboard_<cid>_<eid>` for offline/TV sync.
- **D7 ‚Äî Judges attached to heats**: Event Admin copies the prepared judge roles into each heat‚Äôs `judgesPanel` and Run Console prefers that panel when building judge links and counts.
- **D8 ‚Äî Athlete slot seeding**: Heats auto-seed slot lanes from the event roster (with preset/default sizing) when created or when seeding is triggered, ensuring Run Console order and standings alignment.
- **D9 ‚Äî Judges mismatch indicator**: Run Console surfaces a non-blocking warning when preset and stored judge counts diverge (preserved from prior work but now using the new config pipeline).
- **D10 ‚Äî Preset-driven scoring flow**: Drop-high/low, judge count, runs/tricks, advancement, and judging scale all originate from the preset snapshot/heat record and persist with each heat update.

## üîÑ Persistence & State
- Heat progress (current run, per-run finals, advancement list) saves to `heat_progress_<cid>_<eid>_<heat>` and back into `heats_<cid>_<eid>`.
- Standings auto-refresh after reveals and leaderboard publishes to keep advancers in sync for TVs/offline flows.

## üß™ Validation Notes
- Manual scoring + reveal flow exercised locally to confirm per-run aggregation, run counter updates, standings, and leaderboard writes operate against preset-configured parameters.
- Event Admin ‚ÄúPrepare Judges‚Äù and ‚ÄúAdd Heat‚Äù flows tested to verify judge panel attachment and slot seeding without touching unrelated modules.

## üìå Follow-ups
- TV display surfaces still show finals per athlete; future loops can surface the active run indicator if required.
- Additional automation around progressing to the next run remains manual by design for this loop.
pages/event_admin.html
+113
-8

@@ -191,115 +191,220 @@
        return;
      }

      const rows = [
        ['Discipline', snap.discipline || '‚Äî'],
        ['Runs per Athlete', snap.runsPerAthlete ?? '‚Äî'],
        ['Tricks per Round', snap.tricksPerRound ?? '‚Äî'],
        ['Judges Panel', snap.judges ?? '‚Äî'],
        ['Scoring Format', snap.scoringFormat || '‚Äî'],
        ['Drop High/Low', (snap.dropHighLow === true ? 'Yes' : (snap.dropHighLow === false ? 'No' : '‚Äî'))],
        ['Advancement (Top N)', snap.advancementTopN ?? '‚Äî']
      ];

      el.innerHTML = rows.map(([k, v]) => `<div><b>${k}:</b> ${String(v)}</div>`).join('');
    })();


    document.getElementById('chooseHeat').href = Core.buildUrl('heat_select.html', { cid, eid });

    // === Heats Management Logic ===
    const heatsKey = State.keys.heats(cid, eid);
    let heatsData = State.getJSON(heatsKey, { heats: [] });

    const container = document.getElementById('heatsContainer');
    const emptyBox = document.getElementById('heatsEmpty');
    const rosterKey = State.keys.athletes(cid);

    const getJudgeRolesFromStore = () => {
      const raw = State.getJSON(State.keys.judges(cid), null);
      if (Array.isArray(raw?.roles) && raw.roles.length) return raw.roles.slice();
      if (Array.isArray(raw?.judges) && raw.judges.length) {
        return raw.judges.map(j => j.jid || j.id || j.role || '').filter(Boolean);
      }
      if (Array.isArray(raw) && raw.length) {
        return raw.map(j => j.jid || j.id || j.role || '').filter(Boolean);
      }
      return [];
    };

    const loadRoster = () => {
      const raw = State.getJSON(rosterKey, []);
      if (Array.isArray(raw)) return raw;
      if (Array.isArray(raw?.athletes)) return raw.athletes;
      return [];
    };

    const computeDefaultHeatSize = () => {
      if (Number(heatsData.defaultSize)) return Number(heatsData.defaultSize);
      const snap = (typeof getPresetSnap === 'function' ? getPresetSnap() : null) || {};
      if (Number(snap.heatSize)) return Number(snap.heatSize);
      if (Number(snap.defaultHeatSize)) return Number(snap.defaultHeatSize);
      return 0;
    };

    const refreshHeatsData = () => {
      heatsData = State.getJSON(heatsKey, { heats: [] });
    };

    const ensureSlots = () => {
      refreshHeatsData();
      const heatsList = Array.isArray(heatsData.heats) ? heatsData.heats : [];
      if (!heatsList.length) return;

      const roster = loadRoster();
      const totalHeats = heatsList.length || 1;
      const templateSize = computeDefaultHeatSize();
      const perHeat = templateSize || (roster.length ? Math.ceil(roster.length / totalHeats) : 0);

      const groups = [];
      if (perHeat > 0 && roster.length) {
        roster.forEach((ath, idx) => {
          const g = Math.floor(idx / perHeat);
          (groups[g] || (groups[g] = [])).push(ath);
        });
      }

      const updated = heatsList.map((heat, idx) => {
        const next = Object.assign({}, heat);
        const hasSlots = Array.isArray(next.slots) && next.slots.length > 0;
        if (!hasSlots) {
          const source = groups[idx] || [];
          if (source.length) {
            next.slots = source.map((ath, laneIdx) => ({
              lane: laneIdx + 1,
              aid: ath.aid || ath.id || ath.code || null,
              name: ath.name || ath.displayName || ath.fullName || null
            }));
          } else if (perHeat > 0) {
            next.slots = Array.from({ length: perHeat }, (_, laneIdx) => ({ lane: laneIdx + 1, aid: null, name: null }));
          } else {
            next.slots = [];
          }
        }
        if (next.attemptsPerAthlete == null) {
          const snap = (typeof getPresetSnap === 'function' ? getPresetSnap() : null) || {};
          next.attemptsPerAthlete = snap.runsPerAthlete ?? snap.runs_per_round ?? next.runsPerAthlete ?? 1;
        }
        return next;
      });

      State.setJSON(heatsKey, Object.assign({}, heatsData, { heats: updated }));
      refreshHeatsData();
    };

    document.getElementById('seedJudgesBtn').onclick = () => {
      const key = State.keys.judges(cid);
      const snap = (typeof getPresetSnap === 'function' ? getPresetSnap() : null) || {};
      const presetSize = Number(snap.judges || snap.judgesPanel || snap.scoring?.judges || 0);

      if (!presetSize || presetSize < 1) {
        UI.toast('No judges panel size found in preset');
        return;
      }

      // Always override previous structure for consistency
      const cur = { panelSize: presetSize, roles: [] };
      cur.roles = Array.from({ length: presetSize }, (_, i) => `J${i + 1}`);
      State.setJSON(key, cur);

      UI.toast(`Overridden judges: ${presetSize} role(s) from preset`);
      // Attach judges panel to all heats for Run Console readiness
      refreshHeatsData();
      if (Array.isArray(heatsData.heats) && heatsData.heats.length) {
        const updated = heatsData.heats.map(h => Object.assign({}, h, { judgesPanel: cur.roles.slice() }));
        State.setJSON(heatsKey, Object.assign({}, heatsData, { heats: updated }));
        refreshHeatsData();
        renderHeats();
      }

      UI.toast(`Overridden judges: ${presetSize} role(s) from preset and linked to heats`);
    };


    function renderHeats() {
      refreshHeatsData();
      container.querySelectorAll('.heat-item').forEach(el => el.remove());
      if (!heatsData.heats.length) {
        emptyBox.style.display = 'block';
        return;
      }
      emptyBox.style.display = 'none';

      heatsData.heats.forEach((h, i) => {
        const row = document.createElement('div');
        row.className = 'heat-item';
        const judgeCount = Array.isArray(h.judgesPanel) ? h.judgesPanel.length : (Number(h.judgesCount) || 0);
        const slotsAssigned = Array.isArray(h.slots) ? h.slots.filter(s => s && s.aid).length : 0;
        row.innerHTML = `
  <div style="display:flex;flex-direction:column;">
    <span>Heat ${i + 1}</span>
    <div class="muted" style="font-size:12px;margin-top:4px;">
      ${h.discipline || '‚Äî'} ‚Ä¢ Runs: ${h.runsPerAthlete ?? '‚Äî'} ‚Ä¢ Tricks: ${h.tricksPerRound ?? '‚Äî'} ‚Ä¢ Adv: ${h.advancementTopN ?? '‚Äî'} ‚Ä¢ ${h.scoringFormat || '‚Äî'}
    </div>
    <div class="muted" style="font-size:12px;margin-top:4px;">
      Judges: ${judgeCount || '‚Äî'} ‚Ä¢ Slots seeded: ${slotsAssigned}
    </div>
  </div>
  <div class="heat-actions">
    <a href="${Core.buildUrl('run_console.html', { cid, eid, heat: i + 1 })}">Open</a>
    <a href="${Core.buildUrl('run_console.html', { cid, eid, heat: h.id || h.heatId || (i + 1) })}">Open</a>
    <a href="#" data-index="${i}" class="delHeat">Delete</a>
  </div>
`;

        container.appendChild(row);
      });

      document.querySelectorAll('.delHeat').forEach(btn => {
        btn.onclick = e => {
          e.preventDefault();
          const i = parseInt(btn.dataset.index);
          const i = parseInt(btn.dataset.index, 10);
          heatsData.heats.splice(i, 1);
          State.setJSON(heatsKey, heatsData);
          UI.toast('Heat deleted');
          renderHeats();
        };
      });
    }

    document.getElementById('addHeatBtn').onclick = () => {
      const snap = getPresetSnap() || {};
      const nextNum = heatsData.heats.length + 1;
      refreshHeatsData();
      const nextNum = (Array.isArray(heatsData.heats) ? heatsData.heats.length : 0) + 1;

      const judgeRoles = getJudgeRolesFromStore();
      const rounds = Array.isArray(snap.rounds) ? snap.rounds : [];
      const roundLabel = rounds[nextNum - 1] || rounds[0] || '';

      const newHeat = {
        id: Core.uid('HEAT'),
        name: `Heat ${nextNum}`,
        status: 'pending',

        // --- Preset-derived defaults (read-only at creation; editable later in C5/C6) ---
        discipline: snap.discipline || '‚Äî',
        runsPerAthlete: (snap.runsPerAthlete ?? snap.runs_per_round ?? 2),
        tricksPerRound: (snap.tricksPerRound ?? snap.tricks_per_round ?? 0),
        advancementTopN: (snap.advancementTopN ?? 0),
        scoringFormat: snap.scoringFormat || (snap.scoring && snap.scoring.format) || 'overall_impression',
        judgesPanel: [],          // judge IDs/names will be confirmed later (C3a)
        slots: []                 // athlete assignment happens later (C5)
        dropHighLow: (snap.dropHighLow ?? snap.scoring?.dropHighLow ?? false),
        judgingScale: snap.judgingScale ?? snap.scoring?.scale ?? 100,
        attemptsPerAthlete: (snap.runsPerAthlete ?? snap.runs_per_round ?? 1),
        roundLabel,
        judgesPanel: judgeRoles.slice(),
        slots: []
      };

      heatsData.heats.push(newHeat);
      State.setJSON(heatsKey, heatsData);
      const nextList = Array.isArray(heatsData.heats) ? heatsData.heats.slice() : [];
      nextList.push(newHeat);
      State.setJSON(heatsKey, Object.assign({}, heatsData, { heats: nextList }));
      UI.toast(`Added ${newHeat.name}`);
      ensureSlots();
      renderHeats();
    };


    ensureSlots();
    renderHeats();
  </script>
</body>

</html>
pages/heat_select.html
+39
-5

<!doctype html><html><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Heat Select</title>
<link rel="stylesheet" href="../styles.css">
<script src="../shared/core.js"></script><script src="../shared/state.js"></script><script src="../shared/ui.js"></script>
</head><body><div class="wrap">
  <div class="header">
    <a class="btn" href="javascript:history.back()">‚Üê Back</a>
    <h2 style="margin:0">Choose Heat</h2>
    <span id="tags" class="tag"></span>
  </div>

  <div id="list" class="list"></div>
</div>
<script>
Core.requireParams(['cid','eid'],'competition_home.html');
const cid = Core.getParam('cid'), eid = Core.getParam('eid');
document.getElementById('tags').textContent = `cid=${cid} ‚Ä¢ eid=${eid}`;

const heats = State.arr(State.keys.heats(cid,eid));
const heatKey = State.keys.heats(cid, eid);
const shell = State.getJSON(heatKey, { heats: [] });
const heats = Array.isArray(shell?.heats) ? shell.heats : [];
const events = State.arr(State.keys.events(cid));
const event = events.find(ev => String(ev.eid) === String(eid)) || {};
const presetSnap = event?.preset || State.getJSON('preset_snapshot_' + cid, null);
const rounds = Array.isArray(shell?.rounds) ? shell.rounds
  : Array.isArray(event?.rounds) ? event.rounds
  : (Array.isArray(presetSnap?.rounds) ? presetSnap.rounds : []);

const list = document.getElementById('list');
if (!heats.length) {
  // skeleton: show 2 placeholder heats; no writes
  ['Heat A','Heat B'].forEach((h,i)=>{
  ['Heat A', 'Heat B'].forEach((h, i) => {
    const el = document.createElement('div');
    el.className='card'; el.innerHTML=`<h3>${h}</h3><a class="btn primary" href="${Core.buildUrl('run_console.html',{cid,eid,heat:'H'+(i+1)})}">Open</a>`;
    el.className = 'card';
    el.innerHTML = `<h3>${h}</h3>
      <p class="muted">Round: ‚Äî</p>
      <p class="muted">Status: Not Started</p>
      <a class="btn primary" href="${Core.buildUrl('run_console.html', { cid, eid, heat: 'H' + (i + 1) })}">Open</a>`;
    list.appendChild(el);
  });
} else {
  heats.forEach(h=>{
  heats.forEach((heatObj, idx) => {
    const el = document.createElement('div');
    el.className='card'; el.innerHTML=`<h3>${h.name}</h3><a class="btn primary" href="${Core.buildUrl('run_console.html',{cid,eid,heat:h.id})}">Open</a>`;
    el.className = 'card';
    const heatNumber = idx + 1;
    const heatName = heatObj.name && heatObj.name !== `Heat ${heatNumber}`
      ? `${heatObj.name}` : `Heat ${heatNumber}`;
    const roundLabel = heatObj.roundLabel || heatObj.round || rounds[idx] || rounds[0] || `Round ${heatNumber}`;
    const statusRaw = heatObj.status || 'Not Started';
    const statusNorm = (() => {
      const lower = String(statusRaw).toLowerCase();
      if (lower === 'running') return 'Running';
      if (['done', 'completed', 'complete', 'finalised', 'finalized'].includes(lower)) return 'Completed';
      return typeof statusRaw === 'string' && statusRaw.trim() ? statusRaw : 'Not Started';
    })();
    const heatParam = heatObj.id || heatObj.heatId || heatObj.code || String(heatNumber);
    el.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:1rem;flex-wrap:wrap;">
        <div>
          <h3 style="margin:0 0 .35rem 0;">${heatName}</h3>
          <div class="muted" style="font-size:14px;">Round: ${roundLabel}</div>
          <div class="muted" style="font-size:14px; margin-top:4px;">Status: ${statusNorm}</div>
        </div>
        <a class="btn primary" href="${Core.buildUrl('run_console.html', { cid, eid, heat: heatParam })}">Open</a>
      </div>`;
    list.appendChild(el);
  });
}
</script>
</body></html>
pages/run_console.html
+339
-135

@@ -177,84 +177,92 @@
    }

    /* Make row-1 cards fill their grid tracks */
    .card-status,
    .card-judges {
      height: 100%;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="header">
      <a class="btn" href="javascript:history.back()">‚Üê Back</a>
      <h2 style="margin:0">Run Console</h2>
      <span id="tags" class="tag"></span>
    </div>

    <div class="grid">
      <!-- STATUS -->
      <div class="card card-status">
        <h3>Status</h3>
        <div class="kv">
          <span id="ath" class="tag">Athletes: 0</span>
          <span id="jud" class="tag">Judges: 0</span>
          <span id="lblRunBadge" class="tag">Run 1 / 1</span>
          <span>Heat Status: <b id="lblHeatStatus" class="badge">Not Started</b></span>
        </div>
        <div class="row muted" style="margin-top:.5rem">
        <div class="row muted" style="margin-top:.5rem;gap:.75rem;flex-wrap:wrap;">
          <span id="lblRoundInfo"></span>
          <span id="lblPresetInfo"></span>
          <span id="activeHeatDebug"></span>
        </div>
      </div>

      <!-- JUDGE LINKS (reference only; Step 4 will make real judge page) -->
      <div class="card card-judges">
        <h3>Judge Links</h3>
        <p class="muted">Pilot: you may use Manual Scores below. Judge links are for Step 4.</p>
        <div id="judgeLinks" class="kv"></div>
      </div>

      <!-- RUN CONTROLS -->
      <div class="card card-controls">
        <h3>Run Controls</h3>
        <div class="grid-2">
          <div>
            <div class="row">
              <button id="btnStart" class="btn primary">Start</button>
              <button id="btnLock" class="btn">Lock</button>
              <button id="btnReveal" class="btn primary">Reveal</button>
              <button id="btnUndo" class="btn">Undo</button>
            </div>
            <div class="row" style="margin-top:.5rem">
              <label class="nowrap">
                Athlete for reveal:
                <select id="selAthlete"></select>
              </label>
              <label class="nowrap" style="margin-left:.75rem">
                <input type="checkbox" id="chkDropExtremes"> Drop extremes
              </label>
            </div>
            <div class="row" style="margin-top:.75rem; gap:.5rem;">
              <button id="btnPrevRun" class="btn">‚óÄ Prev Run</button>
              <button id="btnNextRun" class="btn">Next Run ‚ñ∂</button>
              <span class="muted" id="lblRunSummary">Run 1 of 1</span>
            </div>
            <!-- Manual Scores (pilot) -->
            <div style="margin-top:.75rem">
              <div class="muted">Manual Scores (pilot)</div>
              <div class="judge-grid">
                <input id="ms_J1" placeholder="J1 total">
                <input id="ms_J2" placeholder="J2 total">
                <input id="ms_J3" placeholder="J3 total">
                <input id="ms_J4" placeholder="J4 total">
                <input id="ms_J5" placeholder="J5 total">
              </div>
              <div class="row" style="margin-top:.5rem">
                <button id="btnSaveManual" class="btn">Save Manual Scores</button>
                <span class="muted">Writes to scores_<cid>_<eid>_<heat></span>
              </div>
            </div>
          </div>
          <div></div>
        </div>
      </div>
      <!-- DISPLAY CENTRE (separate card) -->
      <div class="card card-display">
        <h3>üé¨ Display Centre</h3>

        <!-- Control row -->
        <div class="row" style="margin-bottom:.5rem">
@@ -279,56 +287,79 @@
        <div class="row" style="gap:.5rem; align-items:flex-start">
          <div style="flex:1">
            <div class="muted" style="margin-bottom:.25rem">Open Screen 1</div>
            <div class="row" style="gap:.5rem; flex-wrap:wrap">
              <button id="openScreen1" class="btn">Open Screen 1</button>
            </div>
          </div>
          <div style="flex:1">
            <div class="muted" style="margin-bottom:.25rem">Open Screen 2</div>
            <div class="row" style="gap:.5rem; flex-wrap:wrap">
              <button id="openScreen2" class="btn">Open Screen 2</button>
            </div>
          </div>
        </div>
      </div>

      <!-- SCORES MONITOR (own full row) -->
      <div class="card card-scores">
        <h3>Scores Monitor</h3>
        <div class="row">
          <span id="lblScoreStatus" class="badge">0/0 submitted</span>
          <span class="muted" id="lblFinalWrap">
            Final (current athlete): <b id="lblFinalScore">‚Äî</b>
          </span>
        </div>
        <div style="margin-top:.5rem;overflow:auto">
        <div id="standingsBlock" style="margin-top:1rem;">
          <div class="row" style="gap:.5rem;align-items:center;">
            <h4 style="margin:0;font-size:1rem;">Heat Standings</h4>
            <span id="lblAdvancement" class="badge muted">Advancement not set</span>
          </div>
          <div style="margin-top:.5rem;overflow:auto;">
            <table class="table" id="tblStandings">
              <thead>
                <tr>
                  <th>Rank</th>
                  <th>Athlete</th>
                  <th>Runs</th>
                  <th>Best</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody>
                <tr><td colspan="5" class="muted">No scores yet.</td></tr>
              </tbody>
            </table>
          </div>
        </div>
        <div style="margin-top:1.25rem;overflow:auto">
          <table class="table" id="tblScores">
            <thead>
              <tr>
                <th>Judge</th>
                <th>Athlete</th>
                <th>Run</th>
                <th>Total</th>
                <th>Time</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <!-- EVENT LOG (own full row) -->
      <div class="card card-log">
        <h3>Event Log</h3>
        <div class="row" style="margin-bottom:.5rem">
          <button id="btnClearLog" class="btn">Clear Log</button>
        </div>
        <div style="max-height:240px; overflow:auto;">
          <div id="eventLog" class="log-box"
            style="background:#111; color:#fff; font-family:monospace; font-size:13px; padding:.6rem; border-radius:6px; min-height:140px; line-height:1.4; white-space: pre-wrap;">
          </div>
        </div>
      </div>


      <script>
        // ---------- PARAMS ----------
@@ -379,577 +410,755 @@

        window.log = function log(m) {
          const line = `[${now()}] ${m}`;
          // UI (name-mapped)
          const athletes = JSON.parse(localStorage.getItem(`athletes_${cid}`) || '[]');
          const id2name = Object.fromEntries(
            athletes.map(a => [String(a.id || a.aid), a.name || a.displayName || a.fullName || a.id])
          );
          const displayLine = line.replace(/\b(A\d+)\b/g, m => id2name[m] || m);
          const ta = el('eventLog');
          ta.textContent += displayLine + "\n";
          ta.scrollTop = ta.scrollHeight;

          // Persist
          try {
            const key = eventLogKey();
            const arr = JSON.parse(localStorage.getItem(key) || '[]');
            arr.push(line);
            if (arr.length > 500) arr.splice(0, arr.length - 500); // keep last 500 lines
            localStorage.setItem(key, JSON.stringify(arr));
          } catch (_) { }
        };


        // ---------- INIT DATA ----------
        const athletes = State.arr(k.athletes);
        const judges = State.arr(k.judges);
        // Normalize judges count from store object or array
        const _judStore = LS.get(k.judges, null);
        const _judCount =
          Array.isArray(_judStore) ? _judStore.length :
            (Array.isArray(_judStore?.roles) ? _judStore.roles.length :
              (Number(_judStore?.panelSize) || 0));
        // Update header badge
        try { el('jud').textContent = `Judges: ${_judCount}`; } catch (_) { }

        const heatsObj = LS.get(k.heats, { heats: [] });
        const heatIdx = Math.max(0, Number(heat) - 1);
        const heatRec = (heatsObj.heats && heatsObj.heats[heatIdx]) ? heatsObj.heats[heatIdx] : { status: 'Not Started' };
        const heatParamRaw = String(heat);
        const heatKey = State.keys.heats(cid, eid);
        const heatsObj = LS.get(heatKey, { heats: [] });
        const heatList = Array.isArray(heatsObj?.heats) ? heatsObj.heats : [];
        const eventsList = State.arr(State.keys.events(cid));
        const currentEvent = eventsList.find(ev => String(ev.eid) === String(eid)) || {};
        const presetSnap = (() => {
          if (currentEvent?.preset) return currentEvent.preset;
          const stored = LS.get('preset_snapshot_' + cid, null);
          if (stored) return stored;
          return null;
        })();

        const athletesStore = State.getJSON(k.athletes, []);
        const athletes = Array.isArray(athletesStore) ? athletesStore
          : (Array.isArray(athletesStore?.athletes) ? athletesStore.athletes : []);
        const athleteNameById = {};
        athletes.forEach(a => {
          const id = String(a.aid || a.id || a.code || a.name || '').trim();
          if (!id) return;
          athleteNameById[id] = a.name || a.displayName || a.fullName || id;
        });

        let heatIdx = -1;
        let heatRec = null;
        if (heatList.length) {
          const asNum = Number(heatParamRaw);
          if (Number.isInteger(asNum) && asNum >= 1 && asNum <= heatList.length) {
            heatIdx = asNum - 1;
            heatRec = heatList[heatIdx];
          }
          if (!heatRec) {
            heatIdx = heatList.findIndex(h =>
              String(h.id) === heatParamRaw ||
              String(h.heatId) === heatParamRaw ||
              String(h.name) === heatParamRaw
            );
            if (heatIdx >= 0) heatRec = heatList[heatIdx];
          }
        }
        if (!heatRec) {
          heatIdx = heatList.length ? 0 : -1;
          heatRec = heatIdx >= 0 ? heatList[heatIdx] : { status: 'Not Started', slots: [] };
        }
        const heatUid = String(heatRec?.id || heatRec?.heatId || heatRec?.name || `IDX_${(heatIdx + 1) || 1}`);
        const heatSlots = Array.isArray(heatRec?.slots) ? heatRec.slots : [];
        const roundsList = Array.isArray(heatsObj?.rounds) ? heatsObj.rounds
          : Array.isArray(currentEvent?.rounds) ? currentEvent.rounds
          : (Array.isArray(presetSnap?.rounds) ? presetSnap.rounds : []);
        const roundLabel = heatRec.roundLabel || heatRec.round || roundsList[heatIdx] || roundsList[0] || 'Round';

        const judgesStore = State.getJSON(k.judges, null);
        const judgeRoles = (() => {
          if (Array.isArray(heatRec?.judgesPanel) && heatRec.judgesPanel.length) return heatRec.judgesPanel.map(String);
          if (Array.isArray(judgesStore?.roles) && judgesStore.roles.length) return judgesStore.roles.map(String);
          if (Array.isArray(judgesStore?.judges) && judgesStore.judges.length) {
            return judgesStore.judges.map(j => String(j.jid || j.id || j.role || '')).filter(Boolean);
          }
          if (Array.isArray(judgesStore) && judgesStore.length) {
            return judgesStore.map(j => String(j.jid || j.id || j)).filter(Boolean);
          }
          const fallbackCount = Number(presetSnap?.judges || judgesStore?.panelSize || presetSnap?.panelSize || 5) || 5;
          return Array.from({ length: fallbackCount }, (_, i) => `J${i + 1}`);
        })();
        const judgeCount = judgeRoles.length;

        const heatConfig = {
          runsPerAthlete: Math.max(1, Math.round(Number(heatRec.runsPerAthlete ?? heatRec.attemptsPerAthlete ?? presetSnap?.runsPerAthlete ?? presetSnap?.runs_per_round ?? 1) || 1)),
          tricksPerRound: Number(heatRec.tricksPerRound ?? presetSnap?.tricksPerRound ?? presetSnap?.tricks_per_round ?? 0) || 0,
          advancementTopN: Number(heatRec.advancementTopN ?? presetSnap?.advancementTopN ?? 0) || 0,
          scoringFormat: String(heatRec.scoringFormat || presetSnap?.scoringFormat || presetSnap?.scoring?.format || 'overall_impression'),
          dropHighLow: (heatRec.dropHighLow ?? presetSnap?.dropHighLow ?? presetSnap?.scoring?.dropHighLow ?? false) === true,
          judgingScale: Number(heatRec.judgingScale ?? presetSnap?.judgingScale ?? presetSnap?.scoring?.scale ?? 100) || 100,
        };
        heatConfig.judges = judgeCount;

        const progressKey = `heat_progress_${cid}_${eid}_${heatUid}`;
        const storedProgress = LS.get(progressKey, null) || heatRec.progress || null;
        const progress = Object.assign(
          { currentRun: 1, totalRuns: heatConfig.runsPerAthlete, runScores: {} },
          (storedProgress && typeof storedProgress === 'object') ? storedProgress : {}
        );
        progress.totalRuns = Math.max(1, Math.round(Number(progress.totalRuns || heatConfig.runsPerAthlete || 1)));
        progress.currentRun = Math.min(Math.max(1, Math.round(Number(progress.currentRun || 1))), progress.totalRuns);
        if (!progress.runScores || typeof progress.runScores !== 'object') progress.runScores = {};

        // ---------- HEADER/UI SEED ----------
        el('tags').textContent = `cid=${cid} ‚Ä¢ eid=${eid} ‚Ä¢ heat=${heat}`;
        el('tags').textContent = `cid=${cid} ‚Ä¢ eid=${eid} ‚Ä¢ heat=${heatParamRaw}`;
        el('ath').textContent = `Athletes: ${athletes.length}`;
        el('jud').textContent = `Judges: ${_judCount}`;
        el('jud').textContent = `Judges: ${judgeCount}`;
        el('lblHeatStatus').textContent = heatRec.status || 'Not Started';
        el('activeHeatDebug').textContent = `(active_heat: ${JSON.stringify(LS.get(k.active) || {})})`;
        if (el('lblRoundInfo')) el('lblRoundInfo').textContent = `Round: ${roundLabel}`;
        if (el('lblPresetInfo')) {
          el('lblPresetInfo').textContent = `Runs ${heatConfig.runsPerAthlete} ‚Ä¢ Tricks ${heatConfig.tricksPerRound} ‚Ä¢ Adv Top ${heatConfig.advancementTopN || '‚Äî'} ‚Ä¢ Scale ${heatConfig.judgingScale}`;
        }
        function updateRunUI() {
          if (el('lblRunBadge')) el('lblRunBadge').textContent = `Run ${progress.currentRun} / ${progress.totalRuns}`;
          if (el('lblRunSummary')) el('lblRunSummary').textContent = `Run ${progress.currentRun} of ${progress.totalRuns}`;
        }
        updateRunUI();

        // ---- D0.4: non-blocking judges mismatch indicator (preset vs store) ----
        (function () {
          try {
            const snap = LS.get('preset_snapshot_' + cid, null);
            const need = Number(snap?.judges) || 0;

            // _judCount was computed earlier (object/array tolerant). Fallback to roles.length.
            let have = (typeof _judCount === 'number') ? _judCount : 0;
            if (!have) {
              const js = LS.get(k.judges, null);
              have = Array.isArray(js?.roles) ? js.roles.length :
                (Array.isArray(js?.judges) ? js.judges.length : (Number(js?.panelSize) || 0));
            }

            const need = Number(presetSnap?.judges || presetSnap?.panelSize || 0);
            const host = document.querySelector('.card-status .kv') || el('jud')?.parentNode;
            if (!host) return;

            const badge = document.createElement('span');
            badge.id = 'warnJudges';
            badge.className = 'badge';
            badge.style.background = '#fff3cd';
            badge.style.color = '#92400e';
            badge.style.cursor = 'pointer';
            badge.style.display = 'none';
            badge.title = 'Preset judges ‚â† stored panel. Click to prepare fix.';
            badge.textContent = '‚ö† Judges Mismatch ‚Äî Click Prepare';
            host.appendChild(badge);

            if (need && have && need !== have) {
            if (need && judgeCount && need !== judgeCount) {
              badge.style.display = 'inline-block';
            }

            badge.onclick = function () {
              // Non-blocking: log intent only (actual prepare step can be run on demand)
              console.log('PREPARE: align judges from preset', { need, have, cid });
              // (Optional future: run the D0.2 align snippet here)
              console.log('PREPARE: align judges from preset', { need, have: judgeCount, cid });
            };
          } catch (_) { /* no-op */ }
        })();


        const nameFromRoster = (id) => athleteNameById[String(id)] || String(id);

        function persistProgress() {
          LS.set(progressKey, progress);
        }

        let latestStandings = { rows: [], advancers: [] };

        function persistHeatSnapshot(extra = {}) {
          if (heatIdx < 0) return;
          const obj = LS.get(heatKey, { heats: [] });
          const arr = Array.isArray(obj.heats) ? obj.heats : [];
          const base = Object.assign({}, arr[heatIdx] || {});
          const next = Object.assign(base, {
            status: base.status || heatRec.status || 'Not Started',
            runsPerAthlete: heatConfig.runsPerAthlete,
            tricksPerRound: heatConfig.tricksPerRound,
            advancementTopN: heatConfig.advancementTopN,
            scoringFormat: heatConfig.scoringFormat,
            dropHighLow: heatConfig.dropHighLow,
            judgingScale: heatConfig.judgingScale,
            judgesPanel: Array.isArray(judgeRoles) ? judgeRoles.slice() : [],
            slots: Array.isArray(base.slots) ? base.slots : heatSlots,
            progress: {
              currentRun: progress.currentRun,
              totalRuns: progress.totalRuns,
              runScores: progress.runScores
            },
            advancers: latestStandings.advancers || []
          }, extra);
          arr[heatIdx] = next;
          obj.heats = arr;
          LS.set(heatKey, obj);
          heatRec = next;
        }

        function computeStandings() {
          const rows = [];
          const seen = new Set();
          heatSlots.filter(s => s && s.aid).forEach((slot, idx) => {
            const aid = String(slot.aid);
            if (!aid || seen.has(aid)) return;
            seen.add(aid);
            rows.push({ aid, name: slot.name || nameFromRoster(aid), lane: slot.lane ?? (idx + 1) });
          });
          Object.keys(progress.runScores).forEach(aid => {
            const key = String(aid);
            if (seen.has(key)) return;
            seen.add(key);
            rows.push({ aid: key, name: nameFromRoster(key), lane: null });
          });

          const fmt = heatConfig.scoringFormat.toLowerCase();
          rows.forEach(row => {
            const runEntries = Array.isArray(progress.runScores[row.aid]) ? progress.runScores[row.aid] : [];
            row.runs = Array.from({ length: progress.totalRuns }, (_, idx) => {
              const entry = runEntries[idx];
              const val = entry && Number.isFinite(Number(entry.final)) ? Number(entry.final) : null;
              return { run: idx + 1, final: val };
            });
            const finals = row.runs.map(r => r.final).filter(v => Number.isFinite(v));
            if (finals.length) {
              if (fmt.includes('average')) {
                const avg = finals.reduce((a, b) => a + b, 0) / finals.length;
                row.best = +avg.toFixed(2);
              } else {
                const max = Math.max(...finals);
                row.best = +max.toFixed(2);
              }
            } else {
              row.best = null;
            }
          });

          rows.sort((a, b) => {
            const aBest = Number.isFinite(a.best) ? a.best : -Infinity;
            const bBest = Number.isFinite(b.best) ? b.best : -Infinity;
            if (bBest !== aBest) return bBest - aBest;
            return (a.lane ?? Infinity) - (b.lane ?? Infinity);
          });

          let rankCounter = 1;
          rows.forEach(row => {
            if (Number.isFinite(row.best)) {
              row.rank = rankCounter++;
            } else {
              row.rank = null;
            }
          });

          const advancers = heatConfig.advancementTopN > 0
            ? rows.filter(r => Number.isFinite(r.best)).slice(0, heatConfig.advancementTopN).map(r => r.aid)
            : [];
          rows.forEach(row => { row.advance = advancers.includes(row.aid); });

          return { rows, advancers };
        }

        function refreshStandings() {
          const badge = el('lblAdvancement');
          if (badge) {
            badge.textContent = heatConfig.advancementTopN > 0
              ? `Top ${heatConfig.advancementTopN} advance`
              : 'Advancement not set';
          }

          const table = el('tblStandings');
          const tbody = table ? table.querySelector('tbody') : null;
          latestStandings = computeStandings();

          if (!tbody) {
            persistHeatSnapshot();
            return;
          }

          if (!latestStandings.rows.length) {
            tbody.innerHTML = '<tr><td colspan="5" class="muted">No scores yet.</td></tr>';
            persistHeatSnapshot();
            return;
          }

          const html = latestStandings.rows.map(row => {
            const runsText = row.runs.map(r => `R${r.run}:${Number.isFinite(r.final) ? r.final.toFixed(2) : '‚Äî'}`).join(' ‚Ä¢ ') || '‚Äî';
            const bestText = Number.isFinite(row.best) ? row.best.toFixed(2) : '‚Äî';
            const statusCell = row.advance
              ? '<span class="badge" style="background:#16a34a1a;border:1px solid #16a34a;color:#166534;">Advance</span>'
              : '<span class="muted">‚Äî</span>';
            return `<tr><td>${row.rank ?? '‚Äî'}</td><td>${nameFromRoster(row.aid)}</td><td>${runsText}</td><td>${bestText}</td><td>${statusCell}</td></tr>`;
          }).join('');

          tbody.innerHTML = html;
          persistHeatSnapshot();
        }

        function recordRunScore(aid, runNumber, finalValue) {
          if (!aid) return;
          const runIdx = Math.max(0, Math.round(Number(runNumber) || 1) - 1);
          if (!Array.isArray(progress.runScores[aid])) progress.runScores[aid] = [];
          progress.runScores[aid][runIdx] = {
            final: Number.isFinite(finalValue) ? +Number(finalValue).toFixed(2) : null,
            ts: Date.now()
          };
          persistProgress();
        }

        function setCurrentRun(nextRun) {
          const target = Math.min(Math.max(1, Math.round(Number(nextRun) || 1)), progress.totalRuns);
          if (target === progress.currentRun) return;
          progress.currentRun = target;
          persistProgress();
          updateRunUI();
          refreshScoresTable();
          persistHeatSnapshot();
        }


        // Athletes picker (preset-first: use heat slots order if present)
        const selAthlete = el('selAthlete');
        (function seedAthleteSelect() {
          if (!selAthlete) return;

          // Build id->name map from athletes store (IDs are canonical; names for display only)
          const id2name = {};
          athletes.forEach(a => {
            const id = String(a.aid || a.id || a.code || a.name || '');
            const nm = a.name || a.displayName || a.fullName || id;
            if (id) id2name[id] = nm;
          });

          // Prefer slots from current heat; fallback to full athletes list
          const slots = (heatsObj && Array.isArray(heatsObj.heats) && heatsObj.heats[heatIdx] && Array.isArray(heatsObj.heats[heatIdx].slots))
            ? heatsObj.heats[heatIdx].slots : [];
          const slots = Array.isArray(heatSlots) ? heatSlots : [];
          const orderedIds = (slots.length ? slots.map(s => String(s.aid)).filter(Boolean)
            : athletes.map(a => String(a.aid || a.id || a.code || a.name)).filter(Boolean));

          // Preserve previous selection if still valid
          const prev = selAthlete.value || localStorage.getItem(`ui_sel_ath_${cid}_${eid}_${heat}`) || '';
          selAthlete.innerHTML = '';
          orderedIds.forEach(id => {
            const opt = document.createElement('option');
            opt.value = id;                          // ‚Üê always store ID
            opt.textContent = id2name[id] || id;     // ‚Üê display name
            selAthlete.appendChild(opt);
          });
          if (prev && [...selAthlete.options].some(o => o.value === prev)) {
            selAthlete.value = prev;
          }
        })();

        refreshStandings();
        refreshScoresTable();

        // --- Generate real Judge URLs (self-contained, no external vars needed)
        (function () {
          var jWrap = document.getElementById('judgeLinks');
          if (!jWrap) return;

          var p = new URLSearchParams(location.search);
          var cid = p.get('cid') || '';
          var eid = p.get('eid') || '';
          var heat = p.get('heat') || '';
          var base = location.origin;

          // get current athlete id (if present) so judge URLs target the same athlete
          var aidSel = document.getElementById('selAthlete');
          var aid = aidSel ? aidSel.value : '';

          // Build ID‚ÜíName map from athletes store (names for display)
          var aStore; try { aStore = JSON.parse(localStorage.getItem('athletes_' + cid) || '[]'); } catch (_) { aStore = []; }
          var aList = Array.isArray(aStore) ? aStore : (aStore.athletes || []);
          var id2name = {};
          aList.forEach(function (a) {
            var id = String(a.aid || a.id || a.code || a.name || '');
            var nm = a.name || a.displayName || a.fullName || id;
            if (id) id2name[id] = nm;
          });
          var aname = aid ? ((window.nameOfAth && window.nameOfAth(aid)) || id2name[aid] || aid) : '';

          // Preset-first roles from judges_<cid> (fallback to J1..J5)
          var jStore; try { jStore = JSON.parse(localStorage.getItem('judges_' + cid) || 'null'); } catch (_) { jStore = null; }
          var roles = (Array.isArray(jStore && jStore.roles) && jStore.roles.length) ? jStore.roles
            : ((Array.isArray(jStore && jStore.judges) && jStore.judges.length) ? jStore.judges.map(function (j) { return j.jid || j.id; }).filter(Boolean)
              : ['J1', 'J2', 'J3', 'J4', 'J5']);
          var roles = Array.isArray(judgeRoles) && judgeRoles.length ? judgeRoles.slice() : ['J1', 'J2', 'J3', 'J4', 'J5'];

          jWrap.innerHTML = '';
          roles.forEach(function (jid) {
            var a = document.createElement('a');
            a.className = 'btn outline';
            a.textContent = 'üéØ ' + jid + (aname ? ' ‚Äî ' + aname : '');
            a.href = base + '/pages/judge.html'
              + '?cid=' + encodeURIComponent(cid)
              + '&eid=' + encodeURIComponent(eid)
              + '&heat=' + encodeURIComponent(heat)
              + '&j=' + encodeURIComponent(jid)
              + (aid ? '&aid=' + encodeURIComponent(aid) : '');
            a.target = '_blank';
            a.rel = 'noopener';
            jWrap.appendChild(a);
          });
        })();

        // Rules + Scores rehydrate
        const rules = LS.get(k.rules, { dropExtremes: false });
        el('chkDropExtremes').checked = !!rules.dropExtremes;
        const rules = LS.get(k.rules, { dropExtremes: heatConfig.dropHighLow });
        if (typeof rules?.dropExtremes === 'boolean') {
          heatConfig.dropHighLow = !!rules.dropExtremes;
        }
        if (el('chkDropExtremes')) el('chkDropExtremes').checked = !!heatConfig.dropHighLow;

        // ---------- CORE ----------
        function setHeatStatus(status) {
          const obj = LS.get(k.heats, { heats: [] });
          obj.heats = obj.heats || [];
          obj.heats[heatIdx] = obj.heats[heatIdx] || {};
          obj.heats[heatIdx].status = status;
          LS.set(k.heats, obj);
          el('lblHeatStatus').textContent = status;
          persistHeatSnapshot({ status });
        }

        function refreshScoresTable() {
          // 1) read both shapes
          const raw = LS.get(k.scores, { results: [] });
          const rows = Array.isArray(raw) ? raw : (Array.isArray(raw.results) ? raw.results : []);

          // 2) normalize accessors (safe lookups)
          const tbl = el('tblScores');
          const tbody = tbl ? (tbl.querySelector('tbody') || tbl) : null;
          const sel = el('selAthlete');
          const drop = el('chkDropExtremes');
          const lblStatus = el('lblScoreStatus');
          const lblFinal = el('lblFinalScore');
          // Safe judge count fallback (when judges list isn't loaded yet)
          const judgeCount = (Array.isArray(judges) && judges.length > 0) ? judges.length : 5;
          const runNo = progress.currentRun;
          if (drop) drop.checked = !!heatConfig.dropHighLow;
          const judgeCount = judgeRoles.length || 5;


          if (tbody) tbody.innerHTML = '';
          const aid = sel ? sel.value : '';
          const list = rows.filter(r => {
            const rAid = String(r.athleteId || r.aid || '');
            return (!aid || rAid === String(aid));
            if (aid && rAid !== String(aid)) return false;
            const rRun = Number(r.run || r.attempt || r.try || 1);
            return rRun === runNo;
          });

          list.forEach(r => {
            const jid = (r.judgeId || r.jid || '-').toString();
            const name = (athletes.find(a => (a.aid || a.id) == (r.athleteId || r.aid)) || {}).name
              || (r.athleteId || r.aid || '-');
            const runLabel = Number(r.run || r.attempt || r.try || runNo);

            const totalNum = (() => {
              if (typeof r.total === 'number') return r.total;

              // read scoring weights from setup
              const scoring = JSON.parse(localStorage.getItem(`scoring_${cid}`) || '{}');
              const criteria = scoring.criteria || [];
              const s = r.totals || r.scores || {};

              if (criteria.length) {
                let sum = 0, sumW = 0;
                criteria.forEach(c => {
                  const key = c.label.toLowerCase().replace(/\s+/g, '_');
                  const val = parseFloat(s[key]);
                  const w = parseFloat(c.weight) || 1;
                  if (!isNaN(val)) { sum += val * w; sumW += w; }
                });
                return sumW ? (sum / sumW) : NaN;
              }

              const nums = Object.values(s).map(Number).filter(Number.isFinite);
              return nums.length ? nums.reduce((a, b) => a + b, 0) / nums.length : NaN;
            })();

            const total = Number.isFinite(totalNum) ? totalNum.toFixed(2) : '‚Äî';
            const time = r.time || (r.ts ? new Date(r.ts).toLocaleTimeString([], { hour12: false }) : '');

            if (tbody) {
              const tr = document.createElement('tr');
              tr.innerHTML = `<td>${jid}</td><td>${name}</td><td>${total}</td><td>${time}</td>`;
              tr.innerHTML = `<td>${jid}</td><td>${name}</td><td>Run ${runLabel}</td><td>${total}</td><td>${time}</td>`;
              tbody.appendChild(tr);
            }
          });

          // update submitted counter
          if (lblStatus) lblStatus.textContent = `${list.length}/${judgeCount} submitted`;
          if (lblStatus) lblStatus.textContent = `${list.length}/${judgeCount} submitted (Run ${runNo})`;


          // Compute "Final (current athlete)" with dynamic-criteria support
          // 1) If row has r.total, use it. 2) Else recompute using scoring_<cid> weights.
          //    Falls back to simple mean of any numeric fields if scoring_<cid> missing.
          const _qs = new URLSearchParams(location.search);
          const _cid = _qs.get('cid') || '';
          let _criteria = [];
          try {
            const _scRaw = localStorage.getItem('scoring_' + _cid);
            if (_scRaw) {
              const _sc = JSON.parse(_scRaw);
              const arr = Array.isArray(_sc?.criteria) ? _sc.criteria : [];
              _criteria = arr.map(c => ({
                slug: String(c.label || c.id || '').toLowerCase().replace(/\s+/g, '_'),
                w: Number(c.weight) || 1
              })).filter(x => x.slug);
            }
          } catch (_) { }

          const totals = list.map(r => {
            if (typeof r.total === 'number') return r.total;

            // accept either r.totals or r.scores
            const s = r.totals || r.scores || {};
            // if we have scoring config, do weighted recompute by slugs
            if (_criteria.length) {
              let sum = 0, wsum = 0;
              for (const { slug, w } of _criteria) {
                const v = Number(s[slug]);
                if (Number.isFinite(v)) { sum += v * w; wsum += w; }
              }
              if (wsum > 0) return sum / wsum;
            }
            // fallback: mean of any numeric fields present
            const vals = Object.values(s).map(Number).filter(Number.isFinite);
            return vals.length ? (vals.reduce((a, b) => a + b, 0) / vals.length) : NaN;
          }).filter(Number.isFinite);


          let final = '‚Äî';
          if (totals.length > 0) {
            let arr = [...totals];
            if (drop && drop.checked && arr.length >= 3) {
            if (heatConfig.dropHighLow && arr.length >= 3) {
              arr.sort((a, b) => a - b);
              arr = arr.slice(1, arr.length - 1);
            }
            final = (arr.reduce((s, v) => s + v, 0) / arr.length).toFixed(2);
          }
          if (lblFinal) lblFinal.textContent = final;

          try { window.log && window.log(`REFRESH ¬∑ ${list.length}/${judgeCount} submitted (Final=${final})`); } catch { }


          return final;

        }


        function saveManualScores() {
          const aid = selAthlete.value;
          const nowStr = now();
          const runNumber = progress.currentRun;
          const inputs = ['J1', 'J2', 'J3', 'J4', 'J5'].map(jid => {
            const v = document.getElementById(`ms_${jid}`)?.value?.trim();
            return { jid, val: v };
          }).filter(x => x.val !== '' && x.val != null);

          if (!inputs.length) { log('No manual scores entered'); return; }

          const store = LS.get(k.scores, { results: [] });
          store.results = store.results || [];

          inputs.forEach(({ jid, val }) => {
            const num = parseFloat(val);
            if (isNaN(num)) return;
            // Replace existing entry for this judge+athlete in this heat
            const idx = store.results.findIndex(r => String(r.jid) === jid && String(r.aid) === String(aid));
            const row = { jid, aid, total: num, time: nowStr };
            const idx = store.results.findIndex(r => String(r.jid) === jid && String(r.aid) === String(aid) && Number(r.run || r.attempt || r.try || 1) === runNumber);
            const row = { jid, aid, total: num, time: nowStr, run: runNumber };
            if (idx >= 0) store.results[idx] = row; else store.results.push(row);
          });

          LS.set(k.scores, store);
          log(`SAVE manual scores for aid=${aid}`);
          log(`SAVE manual scores for aid=${aid} ¬∑ run=${runNumber}`);
          refreshScoresTable();
        }

        /* === STEP 5C-2 PATCH ¬∑ publishReveal() (ID-only, no new keys) === */
        (function () {
          const p = new URLSearchParams(location.search);
          const CID = p.get('cid'), EID = p.get('eid'), HEAT = String(p.get('heat'));

          // Read scoring criteria (for recompute if needed)
          const scoring = LS.get(`scoring_${CID}`, null);
          const criteria = (scoring && Array.isArray(scoring.criteria)) ? scoring.criteria : [];

          function normalizeScoresArray() {
            // Read canonical scores array; tolerate legacy {results:[]}
            let v = LS.get(k.scores, []);
            if (!Array.isArray(v)) v = (v && Array.isArray(v.results)) ? v.results : [];
            return v;
          }

          function slug(s) { return String(s || '').toLowerCase().replace(/\s+/g, '_'); }

          function recomputeFromBag(bag) {
            // bag = r.totals or r.scores with lowercase slug keys
            if (!criteria.length || !bag) return NaN;
            const slugs = criteria.map(c => slug(c.label || c.id));
            const weights = criteria.map(c => Number(c.weight || 0));
            const vals = slugs.map(s => Number(bag[s]));
            if (vals.some(v => !Number.isFinite(v))) return NaN;
            const sumW = (weights.reduce((a, b) => a + b, 0)) || 100;
            const raw = vals.reduce((acc, v, i) => acc + v * weights[i], 0);
            return +(raw / (sumW / 100)).toFixed(2);
          }

          function perJudgeTotalsFor(aid) {
            // latest row per judge for this athlete
            const rows = normalizeScoresArray().filter(r => String(r.aid || r.athleteId) === String(aid));
            const runNumber = progress.currentRun;
            const rows = normalizeScoresArray().filter(r => String(r.aid || r.athleteId) === String(aid)
              && Number(r.run || r.attempt || r.try || 1) === runNumber);
            const map = new Map();
            rows.forEach(r => {
              const jid = String(r.jid || r.judgeId || '');
              map.set(jid, r); // last write wins
            });
            const list = Array.from(map.values()).map(r => {
              if (Number.isFinite(r.total)) return Number(r.total);
              const bag = r.totals || r.scores || {};
              return recomputeFromBag(bag);
            }).filter(Number.isFinite);
            return list;
          }

          function computeFinal(judgeTotals) {
            if (!judgeTotals.length) return null;
            let arr = judgeTotals.slice();
            const rules = LS.get(k.rules, {});
            if (rules && rules.dropExtremes && arr.length >= 3) {
              // drop exactly one min & one max
            if (heatConfig.dropHighLow && arr.length >= 3) {
              const min = Math.min(...arr), max = Math.max(...arr);
              let droppedMin = false, droppedMax = false;
              arr = arr.filter(x => {
                if (!droppedMin && x === min) { droppedMin = true; return false; }
                if (!droppedMax && x === max) { droppedMax = true; return false; }
                return true;
              });
            }
            const avg = arr.reduce((a, b) => a + b, 0) / arr.length;
            return +avg.toFixed(2);
          }

          window.publishReveal = function () {
            const aid = selAthlete.value;
            if (!aid) { log('REVEAL aborted: no athlete selected'); return; }

            const runNumber = progress.currentRun;
            const judgeTotals = perJudgeTotalsFor(aid);
            // Fallback to current table calc (already computed + respects drop-extremes)
            const tableFinal = (function () { try { const s = refreshScoresTable(); return s === '‚Äî' ? null : Number(s); } catch { return null; } })();
            const final = (judgeTotals.length ? computeFinal(judgeTotals) : null) ?? tableFinal;

            const packet = { cid: CID, eid: EID, heat: HEAT, aid, judgeTotals, final };
            const packet = { cid: CID, eid: EID, heat: HEAT, aid, judgeTotals, final, run: runNumber };
            LS.set('reveal', packet);                    // ‚Üê write complete, ID-only packet
            LS.set('reveal_tick', Date.now());           // nudge TVs to re-render (safe)
            log(`REVEAL ¬∑ ${aid} (Final=${final ?? '‚Äî'})`);
            log(`REVEAL ¬∑ ${aid} ¬∑ run=${runNumber} (Final=${final ?? '‚Äî'})`);
            recordRunScore(aid, runNumber, final);
            refreshStandings();
            // --- Auto-update leaderboard (global-safe) ---
            try {
              if (typeof publishLeaderboard === 'function') {
                publishLeaderboard();
                log('AUTO leaderboard publish triggered');
              } else {
                console.warn('publishLeaderboard not found, skipping auto-publish');
              }
            } catch (err) {
              console.error('auto leaderboard publish failed:', err);
            }
          };
        })();



        function publishLeaderboard() {
          const p = new URLSearchParams(location.search);
          const CID = p.get('cid'), EID = p.get('eid'), HEAT = String(p.get('heat'));

          // Read scoring rules (for weighted recompute if needed)
          const scoring = LS.get(`scoring_${CID}`, null);
          const criteria = (scoring && Array.isArray(scoring.criteria)) ? scoring.criteria : [];
          const slug = s => String(s || '').toLowerCase().replace(/\s+/g, '_');
          const rules = LS.get(k.rules, {});

          // Normalize scores array (supports legacy {results:[]})
          let v = LS.get(k.scores, []);
          const rows = Array.isArray(v) ? v : (v && Array.isArray(v.results)) ? v.results : [];

          // Latest row per (aid, jid)
          const latest = new Map();
          for (const r of rows) {
            const aid = String(r.aid || r.athleteId || r.athlete || '');
            const jid = String(r.jid || r.judgeId || '');
            if (!aid || !jid) continue;
            latest.set(`${aid}|${jid}`, r);
          }
          const CID = p.get('cid'), EID = p.get('eid');

          // Build per-athlete judge totals
          const byAid = {};
          for (const r of latest.values()) {
            const aid = String(r.aid || r.athleteId);
            let total = Number.isFinite(r.total) ? Number(r.total) : NaN;
            if (!Number.isFinite(total)) {
              const bag = r.totals || r.scores || {};
              if (criteria.length) {
                const ws = criteria.map(c => Number(c.weight || 0));
                const slugs = criteria.map(c => slug(c.label || c.id));
                const vals = slugs.map(s => Number(bag[s]));
                if (!vals.some(x => !Number.isFinite(x))) {
                  const sumW = ws.reduce((a, b) => a + b, 0) || 100;
                  total = (vals.reduce((acc, v, i) => acc + v * ws[i], 0)) / (sumW / 100);
                }
              } else {
                const nums = [bag.difficulty, bag.execution, bag.flow].map(Number).filter(Number.isFinite);
                if (nums.length) total = nums.reduce((a, b) => a + b, 0) / nums.length;
              }
            }
            if (!Number.isFinite(total)) continue;
            (byAid[aid] || (byAid[aid] = [])).push(total);
          }

          // Apply drop-extremes and compute finals
          const out = [];
          for (const aid in byAid) {
            let arr = byAid[aid].slice();
            if (rules && rules.dropExtremes && arr.length >= 3) {
              const min = Math.min(...arr), max = Math.max(...arr);
              let dm = false, dx = false;
              arr = arr.filter(x => {
                if (!dm && x === min) { dm = true; return false; }
                if (!dx && x === max) { dx = true; return false; }
                return true;
              });
            }
            const final = +(arr.reduce((a, b) => a + b, 0) / arr.length).toFixed(2);
            out.push({ aid, final });
          }

          // Sort + rank; IDs only in storage
          out.sort((a, b) => b.final - a.final);
          const rowsOut = out.map((r, i) => ({ rank: i + 1, aid: r.aid, final: r.final }));
          refreshStandings();
          const rows = latestStandings.rows.filter(row => Number.isFinite(row.best));
          const rowsOut = rows.map((row, idx) => ({ rank: idx + 1, aid: row.aid, final: row.best }));

          LS.set(`leaderboard_${CID}_${EID}`, { rows: rowsOut });
          LS.set('leaderboard_tick', Date.now()); // nudge TVs to refresh
          log(`PUBLISH LEADERBOARD (${rowsOut.length})`);
        }


        function setDisplay(mode) {
          const screen = el('selScreen').value; // live1 | live2
          LS.set(k.display(screen), mode);
          log(`DISPLAY ${screen} ‚Üí ${mode}`);
          updateDisplayStatuses();
        }



        // ---------- BUTTONS ----------
        const btnPrevRun = el('btnPrevRun');
        if (btnPrevRun) btnPrevRun.onclick = () => setCurrentRun(progress.currentRun - 1);
        const btnNextRun = el('btnNextRun');
        if (btnNextRun) btnNextRun.onclick = () => setCurrentRun(progress.currentRun + 1);

        el('btnStart').onclick = () => {
          LS.set(k.active, { cid, eid, heat });
          setHeatStatus('Running');
          el('activeHeatDebug').textContent = `(active_heat: ${JSON.stringify(LS.get(k.active))})`;
          log(`START heat=${heat}`);
        };
        el('btnLock').onclick = () => {
          setHeatStatus('Completed');
          // disable manual inputs after lock
          ['J1', 'J2', 'J3', 'J4', 'J5'].forEach(id => { const inp = document.getElementById(`ms_${id}`); if (inp) inp.disabled = true; });
          log('LOCK');
        };
        el('btnReveal').onclick = publishReveal;
        el('btnUndo').onclick = () => { LS.remove('reveal'); log('UNDO last reveal'); };
        el('btnSetIntro').onclick = () => setDisplay('intro');
        el('btnSetScoreboard').onclick = () => setDisplay('scoreboard');
        el('btnSetLeaderboard').onclick = () => setDisplay('leaderboard');
        el('btnHide').onclick = () => setDisplay('hide');
        el('btnPublishLeaderboard').onclick = publishLeaderboard;
        updateDisplayStatuses();
        // Open TV buttons (temporarily point all to scoreboard until other pages exist)
        el('openScreen1').onclick = () => openTVDisplay('live1');
        el('openScreen2').onclick = () => openTVDisplay('live2');



        el('selScreen').onchange = updateDisplayStatuses;

        el('btnClearLog').onclick = () => {
          el('eventLog').textContent = '';
          try {
            const key = `eventlog_${cid}_${eid}_${heat}`;
            localStorage.removeItem(key);
          } catch (_) { }
        };

        el('btnSaveManual').onclick = saveManualScores;

        el('chkDropExtremes').onchange = (e) => {
          const next = { dropExtremes: !!e.target.checked };
          LS.set(k.rules, next);
          log(`RULES dropExtremes=${next.dropExtremes}`);
          const nextVal = !!e.target.checked;
          heatConfig.dropHighLow = nextVal;
          LS.set(k.rules, { dropExtremes: nextVal });
          persistHeatSnapshot();
          log(`RULES dropExtremes=${nextVal}`);
          refreshScoresTable();
          refreshStandings();
        };
        el('selAthlete').onchange = function () { log('SELECT aid=' + this.value); refreshScoresTable(); };

        // ---------- RECOVERY ----------
        refreshScoresTable();
        const active = LS.get(k.active);
        if (active && active.cid === cid && active.eid === eid && String(active.heat) === String(heat)) {
          el('lblHeatStatus').textContent = 'Running';
          log('RECOVER: active heat restored');
        }

        // Live refresh on storage events (future-proof)
        window.addEventListener('storage', (ev) => {
          if (ev.key === k.scores || ev.key === k.rules) {
            refreshScoresTable();
          }
          if (ev.key === k.display('live1') || ev.key === k.display('live2')) {
            updateDisplayStatuses();
          }
        });

      </script>
      <!-- RUN: judge lock listener -->
      <script>
        (function () {
@@ -1088,56 +1297,51 @@
          var qs = new URLSearchParams(location.search);
          var CID = qs.get('cid') || '';
          var EID = qs.get('eid') || 'default';
          var HEAT = qs.get('heat') || '1';
          var UIKEY = `ui_sel_ath_${CID}_${EID}_${HEAT}`;

          function rebuildJudgeLinks() {
            var jWrap = document.getElementById('judgeLinks');
            if (!jWrap) return;

            var aid = sel.value || '';
            var aname = (window.nameOfAth ? window.nameOfAth(aid) : aid);

            var base = location.origin;
            // Build ID‚ÜíName map from athletes store (names for display)
            var aStore = (function () { try { return JSON.parse(localStorage.getItem('athletes_' + cid) || '[]'); } catch (_) { return []; } })();
            var aList = Array.isArray(aStore) ? aStore : (aStore.athletes || []);
            var id2name = {};
            aList.forEach(function (a) {
              var id = String(a.aid || a.id || a.code || a.name || '');
              var nm = a.name || a.displayName || a.fullName || id;
              if (id) id2name[id] = nm;
            });

            // Preset-first roles from judges_<cid> (fallback to J1..J5)
            var jStore = (function () {
              try { return JSON.parse(localStorage.getItem('judges_' + cid) || 'null'); } catch (_) { return null; }
            })();
            var roles = Array.isArray(jStore?.roles) && jStore.roles.length ? jStore.roles
              : Array.isArray(jStore?.judges) && jStore.judges.length ? jStore.judges.map(function (j) { return j.jid || j.id; }).filter(Boolean)
                : ['J1', 'J2', 'J3', 'J4', 'J5'];
            var roles = Array.isArray(judgeRoles) && judgeRoles.length ? judgeRoles.slice() : ['J1', 'J2', 'J3', 'J4', 'J5'];

            // current athlete id ‚Üí display name
            var aidSel = document.getElementById('selAthlete');
            var aid = aidSel ? aidSel.value : '';
            var aname = aid ? ((window.nameOfAth && window.nameOfAth(aid)) || aid) : '';
            var aname = aid ? ((window.nameOfAth && window.nameOfAth(aid)) || id2name[aid] || aid) : '';

            jWrap.innerHTML = '';
            roles.forEach(function (jid) {
              var a = document.createElement('a');
              a.className = 'btn outline';
              a.textContent = 'üéØ ' + jid + (aname ? ' ‚Äî ' + aname : '');
              a.href = base + '/pages/judge.html'
                + '?cid=' + encodeURIComponent(cid)
                + '&eid=' + encodeURIComponent(eid)
                + '&heat=' + encodeURIComponent(heat)
                + '&j=' + encodeURIComponent(jid)
                + (aid ? '&aid=' + encodeURIComponent(aid) : '');
              a.target = '_blank';
              a.rel = 'noopener';
              jWrap.appendChild(a);
            });
          }

          // restore last selection (if present and valid)
